<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python字典学习</title>
    <link href="/2022/04/26/Python%E5%AD%97%E5%85%B8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/26/Python%E5%AD%97%E5%85%B8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、<strong>概念</strong></h2><p><strong>字典</strong>（dictionary）是保存键（key）和值（value）之间关联的容器。字典中的每一个键都有一个关联的值。键是唯一的，但一个值可以与多个键相连。键和值之间的关系可以用如下映射表示：</p><p><img src="/img/content_img/1.png" alt="image-20220425221638779"></p><h3 id="1、创建一个字典"><a href="#1、创建一个字典" class="headerlink" title="1、创建一个字典"></a>1、创建一个字典</h3><p>假设现在要编写一个程序要求学生和其爱吃的水果相对应，就可以使用一个字典，其中学生是键，水果是值。这样还能够将一个水果关联多人。第一个键和值一般是默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs Python">content=&#123;<span class="hljs-string">&quot;non-existent&quot;</span>:<span class="hljs-string">&quot;Default&quot;</span>,<span class="hljs-string">&quot;Bob&quot;</span>:<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Mary&quot;</span>:<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;John&quot;</span>:<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Fred&quot;</span>:<span class="hljs-string">&quot;Apple&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>键和值之间使用英文冒号分隔，将键和值用大括号连接起来。但是一个空的大括号表示一个空字典，而不是一个空集合。</p><p>还可以使用dict函数创建一个副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">oldcontent=<span class="hljs-built_in">dict</span>(content)<br></code></pre></td></tr></table></figure><h3 id="2、访问字典的值"><a href="#2、访问字典的值" class="headerlink" title="2、访问字典的值"></a>2、访问字典的值</h3><p>下标运算符[]用于返回与键关联的值。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Bob&#x27;s favoriate fruit is &quot;</span>,content[<span class="hljs-string">&quot;Bob&quot;</span>])<br></code></pre></td></tr></table></figure><p>注意[]内的值必须和键一模一样，即如果在定义键的时候加上了双引号，那么引用的时候也要加上双引号。此外，字典也不是列表那样有序列，即不能通过索引或位置访问数据项，只能使用关联的键访问。访问时键必须是有效键，否则编译器会报出KeyError错误，一种有效的方法是通过in运算符检测所使用的键是否是有效键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Bob&quot;</span> <span class="hljs-keyword">in</span> content:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Bob&#x27;s favoriate fruit is&quot;</span>,content[<span class="hljs-string">&quot;Bob&quot;</span>])<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;KeyError!&quot;</span>)<br></code></pre></td></tr></table></figure><p>此外，如果键不存在，还可以使用默认值。即如果用户输入了一个不存在的键，那么就返回Default，只需要调用get方法并传递检核默认值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">default=content.get(name,<span class="hljs-string">&quot;Default&quot;</span>)<br><span class="hljs-built_in">print</span>(default)<br></code></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>这样就可以写出比较完善的代码了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个字典</span><br>content=&#123;<span class="hljs-string">&quot;non-existent&quot;</span>:<span class="hljs-string">&quot;default&quot;</span>,<span class="hljs-string">&quot;Bob&quot;</span>:<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Mary&quot;</span>:<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;John&quot;</span>:<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Fred&quot;</span>:<span class="hljs-string">&quot;Apple&quot;</span>&#125;<br><span class="hljs-comment"># 备份数据</span><br>oldcontent=<span class="hljs-built_in">dict</span>(content)<br><span class="hljs-comment"># 用户输入</span><br>name=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Please the name you want to inquire:&quot;</span>)<br><span class="hljs-comment"># 判断用户输入的键是否存在，如果不存在就返回默认值Default</span><br><span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> content:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Bob&#x27;s favoriate fruit is&quot;</span>,content[name])<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 使用get方法传递默认值</span><br>default=content.get(name,<span class="hljs-string">&quot;Default&quot;</span>)<br>    <span class="hljs-built_in">print</span>(default)<br></code></pre></td></tr></table></figure><h3 id="3、添加、修改和删除数据项"><a href="#3、添加、修改和删除数据项" class="headerlink" title="3、添加、修改和删除数据项"></a><strong>3、添加、修改和删除数据项</strong></h3><p>字典是可变的容器，也就是说在定义过一个字典之后，可以更改其内容。</p><p>要添加新的数据项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">content[<span class="hljs-string">&quot;Alice&quot;</span>]=<span class="hljs-string">&quot;Banana&quot;</span><br></code></pre></td></tr></table></figure><p>要更改Bob喜欢的水果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">content[<span class="hljs-string">&quot;Bob&quot;</span>]=<span class="hljs-string">&quot;Apple-And-Pear&quot;</span><br></code></pre></td></tr></table></figure><p>要删除一个数据项，需要调用pop方法，它使用键作为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">content.pop[<span class="hljs-string">&quot;Alice&quot;</span>]<br></code></pre></td></tr></table></figure><p>这样就会删除键和其对应的值。同样如果键不在字典中会爆出KeyError错误，可以像上文一样使用in方法检测。</p><h3 id="4、遍历字典"><a href="#4、遍历字典" class="headerlink" title="4、遍历字典"></a><strong>4、遍历字典</strong></h3><p>使用for循环可以遍历字典中的每一个键（注意只是键）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content:&quot;</span>)<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> content:<br>    <span class="hljs-built_in">print</span>(key)<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Content:</p><p>non-existent</p><p>Bob</p><p>Mary</p><p>John</p><p>Fred</p></blockquote><p>将循环变量和下标运算符一起使用，可以访问与键关联的值，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content:&quot;</span>)<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> content:<br>    <span class="hljs-comment"># 一下语句中%-10s是格式控制符，-表示左对齐，10表示占据十个键位，不足则用空格补齐，s表示数据格式是字符串</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%-15s %s&quot;</span> % (key,content[key]))<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Content:</p><p>non-existent     Default</p><p>Bob                     Apple</p><p>Mary                   Pear</p><p>John                    Grape</p><p>Fred                    Apple</p></blockquote><p>此外访问数据基于数据项在内存中的顺序。为了按顺序遍历，可以使用sorted()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content:&quot;</span>)<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(content):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%-15s %s&quot;</span> % (key,content[key]))<br></code></pre></td></tr></table></figure><p>这样就会按照首字母顺序打印。</p><h3 id="5、字典常见操作小结"><a href="#5、字典常见操作小结" class="headerlink" title="5、字典常见操作小结"></a><strong>5、字典常见操作小结</strong></h3><p><strong>常见字典运算操作</strong></p><table><thead><tr><th>运算操作</th><th>说明</th></tr></thead><tbody><tr><td>d&#x3D;dict()    d&#x3D;dict(c)</td><td>创建一个空字典或者字典c的副本</td></tr><tr><td>d&#x3D;{}    d&#x3D;{k1:v1,k2:v2,……kn:vn}</td><td>创建一个空字典或者创建一个提供初始数据的字典</td></tr><tr><td>len(d)</td><td>返回字典d中数据项的数量</td></tr><tr><td>key in d       key not in d</td><td>确定key在字典d中或者key不在字典d中</td></tr><tr><td>d[key]&#x3D;value</td><td>如果key不存在就添加key和他的值到字典d中，如果key存在就修改key的值</td></tr><tr><td>d.get(key,default)</td><td>返回给定键的值，如果key不存在则返回默认值</td></tr><tr><td>d.pop(key)</td><td>删除数据项key</td></tr><tr><td>d.values()</td><td>返回包含在字典中的所有值的序列</td></tr></tbody></table><p><strong>字典的排序操作</strong></p><p>有时候需要对生成的字典的结果按照key或者value进行排序，主要用到的方法就是python的内置函数<strong>sorted()<strong>。sorted()函数的作用是对所有</strong>可迭代</strong>的对象进行排序操作的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">sorted</span>(iterable， key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>) <br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>iterable：是可迭代的数据类型。</li><li>key：用于进行比较的数据。</li><li>reverse：排序规则，默认是True降序，或者设置为False来升序。</li></ul><p>看不懂就看下面的：</p><p>1、基本形式列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。排序，数字、字符串按照ASCII，中文按照unicode从小到大排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=&#123;<span class="hljs-number">10</span>:<span class="hljs-string">&quot;ten&quot;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-number">8</span>:<span class="hljs-string">&quot;eight&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x))<br><span class="hljs-comment"># sorted返回一个有序的副本，并且类型总是列表，如下：</span><br><span class="hljs-comment"># 输出结果是[1,3,4,8,10]</span><br></code></pre></td></tr></table></figure><p>2、可选参数</p><p>sort方法还有两个选参数:key和Reverse</p><ul><li>key在使用时必须提供一个排序过程总调用的函数，例如key&#x3D;abs就是按照绝对值排序，key&#x3D;len就是按照字符串长度排序。实际上key后面的的值是一个匿名函数，这个函数作用于列表元素身上。根据这个函数从每个列表元素中找到排序元素key。然后根据key进行排序。比如key&#x3D;str.lower，就是忽略大小写之后进行字母排序。杂例如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=&#123;<span class="hljs-number">10</span>:<span class="hljs-string">&quot;ten&quot;</span>,-<span class="hljs-number">1</span>:<span class="hljs-string">&quot;-one&quot;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&quot;three&quot;</span>,-<span class="hljs-number">8</span>:<span class="hljs-string">&quot;-eight&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x,key=<span class="hljs-built_in">abs</span>))<br><span class="hljs-comment"># 虽然是按照绝对值排序，但是并不会改变数据项的值</span><br><span class="hljs-comment"># 输出结果是[-1,3,4,-8,10]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x=&#123;<span class="hljs-string">&quot;three&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;ten&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;six&quot;</span>:<span class="hljs-number">6</span>,<span class="hljs-string">&quot;eight&quot;</span>:<span class="hljs-number">8</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x,key=<span class="hljs-built_in">len</span>))<br><span class="hljs-comment"># 以下结果虽然是单引号，但实际上并无差别</span><br><span class="hljs-comment"># 输出结果是[&#x27;ten&#x27;,&#x27;six&#x27;,&#x27;three&#x27;,&#x27;eight&#x27;]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=[&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Mary&quot;</span>,<span class="hljs-string">&quot;score&quot;</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Fred&quot;</span>,<span class="hljs-string">&quot;score&quot;</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&quot;score&quot;</span>:<span class="hljs-number">9</span>&#125;]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x,key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-string">&quot;score&quot;</span>]))<br><span class="hljs-comment"># lambda作为一个表达式，定义了一个匿名函数，使得函数的表达更为简洁也就是说key=lambda x: x[0]其实是根据key后面的函数，作用于列表元素身上。根据这个函数从每个列表元素身上找到排序元素key。然后再依据key进行排序。具体是什么函数根据要求来定，比如key=str.lower，就是忽略大小写后，进行字母排序</span><br><br><span class="hljs-comment"># 输出结果是[&#123;&#x27;name&#x27;: &#x27;Mary&#x27;, &#x27;score&#x27;: 4&#125;, &#123;&#x27;name&#x27;: &#x27;Fred&#x27;, &#x27;score&#x27;: 8&#125;, &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;score&#x27;: 9&#125;]</span><br></code></pre></td></tr></table></figure><ul><li>reverse实现降序排序，需要提供一个布尔值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=&#123;<span class="hljs-number">10</span>:<span class="hljs-string">&quot;ten&quot;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-number">8</span>:<span class="hljs-string">&quot;eight&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x,reverse=<span class="hljs-literal">True</span>))<br><span class="hljs-comment"># False代表正序，True代表逆序，默认值是False</span><br><span class="hljs-comment"># 输出结果是[10,8,4,3,1]</span><br></code></pre></td></tr></table></figure><p>有了这些知识做铺垫，就可以使用for循环来逆序输出字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=&#123;<span class="hljs-number">10</span>:<span class="hljs-string">&quot;ten&quot;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-number">8</span>:<span class="hljs-string">&quot;eight&quot;</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(x,reverse=<span class="hljs-literal">True</span>):<br>    <span class="hljs-built_in">print</span>(x[key],end=<span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-comment"># 输出结果是：ten,eight,four,three,one</span><br></code></pre></td></tr></table></figure><blockquote><p>sort()和sorted()的区别：</p><p>sort()没有返回值，而且会改变源字典中的排序方式；sorted()在调用之后会返回一个排序后的列表，不会改变原数组的排序方式。</p><p>li&#x3D;[‘This’,’is’,’a’,’Boy’,’!’]<br>l&#x3D;[i.lower() for i in li]<br>l.sort()<br>对原列表进行排序，无返回值,原列表发生变化<br>print(l)<br>上面两行代码可以直接使用一句print(sorted(li))代替，结果不会有变化，唯一的区别在于源列表再次不发生变化<br>print(li)<br>这行代码可以让您比较s使用sort()对源列表造成的影响</p><p>注意：由于l.sort()已经改变l的结构，所以l和li不在等价；由于sort()没有返回值，所以任何诸如a&#x3D;l.sort()都是错误的。</p><p>字典也是一样的道理，这个自己下去做实验吧！</p></blockquote><p><strong>遍历字典中的数据项的另一种方法</strong></p><p>在python中使用items方法可以遍历字典中的数据项。这笔遍历键然后使用每个键查找值得效率更高。items方法返回所有数据项的元组（包括键和值）系列，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> content.items():<br>    <span class="hljs-built_in">print</span>(item[<span class="hljs-number">0</span>],item[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>也可以直接使用元组赋值语句，和上面等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> (key,value) <span class="hljs-keyword">in</span> content.items():<br>    <span class="hljs-built_in">print</span>(key,value)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA加密系统</title>
    <link href="/2022/04/08/RSA%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/08/RSA%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA公钥加密系统"><a href="#RSA公钥加密系统" class="headerlink" title="RSA公钥加密系统"></a>RSA公钥加密系统</h1><p>通过公钥加密系统，可以实现对两个通信单位进行加密，这样即使传递的信息被黑客截取，也无法被其利用。公钥加密系统还可以让通信双方在电子信息末尾添加一个电子签名，这种电子签名无法被伪造，而且任何人都能轻易的核对签名的正确与否。</p><p>RSA公钥加密系统主要基于以下事实：寻找一个大素数是容易的，但是把一个大素数分解成正确的两个大素数的积是困难的。</p><h2 id="公钥加密系统和数字签名的实现"><a href="#公钥加密系统和数字签名的实现" class="headerlink" title="公钥加密系统和数字签名的实现"></a>公钥加密系统和数字签名的实现</h2><p><strong>公钥加密系统</strong></p><p>在一个公钥加密系统中，双方参与者都有一个公钥和一个私钥，公钥可以对任何人透露，甚至可以公之于众。实际上，公钥如果可以以一张清单的形式在一个公开目录中看到，会极大便利于信息的传递。现在假设有参与者A和参与者B，参与者A具有公钥P<sub>A</sub>，私钥S<sub>A</sub>，参与者A具有公钥P<sub>B</sub>，私钥S<sub>B</sub>。加密系统中任何一对公钥和私钥的关系都要像函数和反函数的关系一样，才能实现信息的加密和解密，比如要使用公钥加密系统加密一个信息M，那么就必须实现以下等式.</p><blockquote><p>M&#x3D;P<sub>A</sub> ( S<sub>A</sub> ( M ) )&#x3D;S<sub>A</sub> ( P<sub>A</sub> ( M ) )</p></blockquote><p>即无论应用那种次序，运用公钥和私钥对M进行相继变换之后，仍然得到信息M</p><p>发送信息的流程如下：</p><ul><li>A从一个公共目录或者直接向B索要他的公钥P<sub>B</sub></li><li>A将要发送的的信息通过公钥转换成密文C&#x3D;P<sub>B</sub> ( M )，并把它发送给B</li><li>当B收到来自A的密文之后，使用自己的私钥S<sub>B</sub>解密，由于P<sub>B</sub>和S<sub>B</sub>的关系就像函数和反函数的关系一样，所以用私钥S<sub>B</sub>解密之后的数据就是A想要发送的数据M</li></ul><blockquote><p>在《算法导论》中，我看到这里其实有一点疑惑，那就是既然公钥P<sub>B</sub>是公开的，那是否可以通过P<sub>B</sub>来反解出密文M呢？实际上，这也正是RSA公钥加密系统着力解决的问题</p></blockquote><p><strong>数字签名</strong></p><p>同样的，运用公钥加密系统的思想也很容易实现数字签名：</p><p>A将自己的数字签名$&#x3D;S<sub>A</sub>(M’)，附加到消息M’的文件末尾，在B看到数字签名( M’, $ )之后，用从公开目录得到的P<sub>A</sub>进行验证等式M’&#x3D;S<sub>A</sub>($)是否成立，如果不成立，那么数字签名很可能已经被篡改</p><h2 id="RSA加密系统"><a href="#RSA加密系统" class="headerlink" title="RSA加密系统"></a>RSA加密系统</h2><p>在RSA加密系统中，一个参与者按下列过程创建他的公钥和私钥：</p><ul><li>随机选取两个<strong>大素数</strong>p和q，使得p!&#x3D;q，例如p和q可能各有1024位</li><li>计算n&#x3D;pq</li><li>选取一个与φ(n)互质的小奇数e，φ(n)&#x3D;(p-1)(q-1)</li><li>对于模φ(n)，计算出e的乘法逆元d的值</li><li>将P&#x3D;（e，n）对外公开，并作为参与者的RSA公钥</li><li>将S&#x3D;（d，n）保密，并作为参与者的RSA密钥</li></ul><p>为了变换与公钥P&#x3D;（e，n）相关的信息M，计算：</p><blockquote><p>P(M)&#x3D;M<sup>e</sup> mod n</p></blockquote><p>为了变换与密钥S&#x3D;（d，n）相关的密文C，计算：</p><blockquote><p>S(C)&#x3D;C<sup>d</sup>  mod n</p></blockquote><h1 id="补充数论数学知识"><a href="#补充数论数学知识" class="headerlink" title="补充数论数学知识"></a>补充数论数学知识</h1><p><strong>整除性与约数</strong></p><p>一个数被另一个整数整除是数论中的一个重要概念。符号d|a（读作”d整除a“）的含义是，存在某个正整数k，使得a &#x3D; kd。如果a&gt;&#x3D;0, d|a,那么|d|&lt;&#x3D;|a|，且称a是d的倍数。如果d&gt;&#x3D;0，则称d是a的约数。</p><p><strong>素数与合数</strong></p><p>如果一个整数a&gt;1且只能被平凡约束1和他自身所整除，这个数就是素数。如果a&gt;1且不是素数，那这个数就是合数。称整数1是一个基本单位，并且它既不是素数也不是合数，同样0和所有的负整数也既不是素数也不适合数。</p><p><strong>除法定理、余数和等模</strong></p><ul><li><p>除法定理</p><p>对于任何整数a和任何正整数n，存在唯一整数q和r，满足0&lt;&#x3D;r&lt;n且a&#x3D;qn+r</p></li></ul><p>值r&#x3D;a mod n为除法的余数。n|a当且仅当a mod n &#x3D; 0</p><p><strong>最大公约数</strong></p><p>最大公约数即为Greatest Common Divisor，常缩写为gcd。一组整数的公约数，是指同时是这组数中每一个数的约数的数。±1是任意一组整数的公约数。一组整数的最大公约数，是指所有公约数里面最大的一个。</p><p>定理：</p><blockquote><p>如果任意整数a和b不都为0，则gcd（a，b）是a和b的线性组合集{ax+by: x,y∈Z}中最小正元素</p><p>推论：</p><p>对于任意正整数a和b，如果d|a且d|b，则d|gcd（a，b）</p></blockquote><p><strong>互质数</strong></p><p>对于任意正整数a和b，如果gcd（a，b）&#x3D;1则a和b为互质数</p><p>定理：</p><blockquote><p>对于任意正整数a、b和p，如果gcd（a，p）&#x3D;1且gcd（b，p）&#x3D;1，则gcd（ab，p）&#x3D;1</p></blockquote><h2 id="1、最大公约数"><a href="#1、最大公约数" class="headerlink" title="1、最大公约数"></a>1、最大公约数</h2><p><strong>欧几里得算法</strong></p><p>已知两个数a和b，如何求出二者的最大公约数呢？</p><p>假设a&gt;b，如果b是a的约数，那么b就是两者的最大公约数。下面讨论不能整除的情况，即a&#x3D;b×q+r，其中r&lt;b。通过证明可以得到gcd(a, b) &#x3D; gcd(b, a mod b)。那么也就得到了关于两个数的最大公约数的一个递归求法。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//C++</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b,a%b)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">return</span> gcd(b, a % b)<br></code></pre></td></tr></table></figure><p>上述算法被称作欧几里得算法（Euclidean algorithm）。</p><h2 id="2、同余"><a href="#2、同余" class="headerlink" title="2、同余"></a>2、同余</h2><p><strong>同余</strong></p><p>a和b是两个整数，如果它们的差a-b能够被另一个整数n整除，则称a，b对于模n同余，记作a≡b (mod n)，读作a与b关于模n同余（a is congruent to b mod n）。a≡b (mod n)的等价形式是当且仅当n|(a-b)，a,b对于模可理解为a-b&#x3D;kn，k是任意整数。当a≡0 (mod n)时，则n|a。</p><p>性质：</p><blockquote><p>如果a ≡ b (mod n)</p><p>a + c ≡ b + c (mod n)</p><p>a - c ≡ b - c (mod n)</p><p>ac ≡ bc (mod n)</p></blockquote><p>把型如ax≡b (mod n)的方程称为线性同余方程。在数论中，线性同余方程是最基本的同余方程，“线性”表示方程的未知数次数是一次。</p><p>同余方程的解有三种情况，只有当GDD(a, n)|b时，方程有解，例如：</p><div class="code-wrapper"><pre><code class="hljs">　　1. 无解，例如2x≡1 (mod 4)；</code></pre></div><p>   　　2. 有唯一解，例如2x≡1 (mod 5)；<br>            　　3. 有无数解，例如2x≡0 (mod 4)；</p><h2 id="3、欧拉函数"><a href="#3、欧拉函数" class="headerlink" title="3、欧拉函数"></a>3、欧拉函数</h2><p>对正整数n，欧拉函数（Euler’s totient function）是小于n的正整数中与n互质的正整数的个数，用φ(n)表示。欧拉函数又称为φ函数、欧拉商数等，φ(n)的值被称为n的欧拉数。规定φ(1)&#x3D;1。例如，在小于8的正整数中，1,3,5,7都与8互质，因此φ(8)&#x3D;4，φ(8)是一个欧拉函数，它的值等于4，4是8的欧拉数。</p><p>当n是素数时，φ(n)&#x3D;n-1，因为所有小于n的数都和n互素。</p><p>注：当年欧拉认可1是素数，所以在欧拉函数中1也被加了上去。下文在讨论欧拉函数时都把1视为素数。</p><p>欧拉函数有一个性质，如果n可以分解为两个互素正整数p和q的乘积，那么n的欧拉函数就是p和q的欧拉函数的乘积，即：</p><blockquote><p>φ(n) &#x3D; φ(pq) &#x3D; φ(p)φ(q) &#x3D; (p-1)(q-1)</p></blockquote><p>例如，小于12的正整数中与12互质的有1,5,7,11，所以φ(12)&#x3D;4。12可以分解为两个互素的数3和4的乘积，因此：</p><blockquote><p>φ(12) &#x3D; φ(3×4) &#x3D; φ(3)φ(4) &#x3D; (3-1)φ(4) &#x3D; 2φ(4) &#x3D; 4</p></blockquote><p>这里也许会产生一个冲动，把φ(4)继续写成φ(4)&#x3D; 4-1，这是错误的，φ(n)&#x3D;n-1的前提是n是素数，因此φ(4)≠4-1。另一个冲动是写成φ(4)&#x3D; φ(2) φ(2)，这也是错误的，两个数互素的前提是它们的最大公约数是1，GCD(2,2)&#x3D;2，因此2和2并不互素。</p><p><strong>费马小定理</strong></p><blockquote><p>若正整数a,p互质，则a<sup>p</sup> ≡ a (mod p)</p></blockquote><p><strong>欧拉定理</strong></p><blockquote><p>若正整数a,p互质，则a<sup>φ(p)</sup> ≡ 1 (mod p)</p></blockquote><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取两个素数的思路也很简单，就是先取两个大的奇数，然后在检验这两个奇数是不是素数</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randrange<br><br><br><span class="hljs-comment"># 得到一个在(2 ** (n - 1) + 1, 2 ** n)范围内的随机奇数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_n_bit_odd</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">assert</span> n &gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> randrange(<span class="hljs-number">2</span> ** (n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ** n, <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 列举在2之后的50个质数</span><br>first_50_primes = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>,<br>                   <span class="hljs-number">37</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">67</span>, <span class="hljs-number">71</span>, <span class="hljs-number">73</span>,<br>                   <span class="hljs-number">79</span>, <span class="hljs-number">83</span>, <span class="hljs-number">89</span>, <span class="hljs-number">97</span>, <span class="hljs-number">101</span>, <span class="hljs-number">103</span>, <span class="hljs-number">107</span>, <span class="hljs-number">109</span>, <span class="hljs-number">113</span>, <span class="hljs-number">127</span>,<br>                   <span class="hljs-number">131</span>, <span class="hljs-number">137</span>, <span class="hljs-number">139</span>, <span class="hljs-number">149</span>, <span class="hljs-number">151</span>, <span class="hljs-number">157</span>, <span class="hljs-number">163</span>, <span class="hljs-number">167</span>, <span class="hljs-number">173</span>, <span class="hljs-number">179</span>,<br>                   <span class="hljs-number">181</span>, <span class="hljs-number">191</span>, <span class="hljs-number">193</span>, <span class="hljs-number">197</span>, <span class="hljs-number">199</span>, <span class="hljs-number">211</span>, <span class="hljs-number">223</span>, <span class="hljs-number">227</span>, <span class="hljs-number">229</span>, <span class="hljs-number">233</span>]<br><br><br><span class="hljs-comment"># 进行初步素性检验，内部for循环用素数数组的元素逐个筛选，失败就马上中止回到外循环，再调用第一步的函数生成下一个候选奇数重新测试：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_lowlevel_prime</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        c = generate_n_bit_odd(n)<br>        <span class="hljs-keyword">for</span> divisor <span class="hljs-keyword">in</span> first_50_primes:<br>            <span class="hljs-keyword">if</span> c % divisor == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> divisor ** <span class="hljs-number">2</span> &lt;= c:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-comment"># 使用rabin算法进行素性检验</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">miller_rabin_primality_check</span>(<span class="hljs-params">n, k=<span class="hljs-number">20</span></span>):<br>    <span class="hljs-keyword">assert</span> n &gt; <span class="hljs-number">3</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    s, d = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> d % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        d &gt;&gt;= <span class="hljs-number">1</span><br>        s += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        a = randrange(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>)<br>        x = <span class="hljs-built_in">pow</span>(a, d, n)<br><br>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> x == n - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s):<br>            x = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">2</span>, n)<br>            <span class="hljs-keyword">if</span> x == n - <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># 包装以上函数num_bits就是我们需要的素数的位数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_random_prime</span>(<span class="hljs-params">num_bits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        pp = get_lowlevel_prime(num_bits)<br>        <span class="hljs-keyword">if</span> miller_rabin_primality_check(pp):<br>            <span class="hljs-keyword">return</span> pp<br><br><br><span class="hljs-comment"># 随机选取两个超大质数p,q</span><br>p = get_random_prime(<span class="hljs-number">12</span>)<br>q = get_lowlevel_prime(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(q)<br><span class="hljs-built_in">print</span>(p)<br><br><span class="hljs-comment"># 两个已选取的质数p,q相乘记作N</span><br>N = p * q<br><br><span class="hljs-comment"># 计算欧拉函数的值记作t</span><br>T = (q - <span class="hljs-number">1</span>) * (p - <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 选取公钥e</span><br>e = <span class="hljs-number">65537</span><br><br><br><span class="hljs-comment"># 计算私钥，记d是e关于t的模逆元，求取模逆元用扩展欧几里得算法，下列所示函数中old_s就是所求模逆元d</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ext_euclid</span>(<span class="hljs-params">a, b</span>):<br>    old_s, s = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    old_r, r = a, b<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, a<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">while</span> r != <span class="hljs-number">0</span>:<br>            temp = old_r // r<br>            old_r, r = r, old_r - temp * r<br>            old_s, s = s, old_s - temp * s<br>    <span class="hljs-keyword">return</span> old_s<br><br><br>d = ext_euclid(e, T)<br><br><span class="hljs-comment"># 分别输出公钥和私钥</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Public key: (%d, %d)&quot;</span> % (N, e))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Private key: (%d, %d)&quot;</span> % (N, d))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Please enter the information you want to transmit:&quot;</span>)<br>information = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-comment"># 利用已知公钥加密：B将信息按照约定格式转化为小于N的非负整数n,加密方法为encrypt=information**e mod N</span><br>encrypt = (information ** e) % N<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The encrypted data is: &quot;</span>)<br><span class="hljs-built_in">print</span>(encrypt)<br><br><span class="hljs-comment"># A收到来自B的加密消息之后利用私钥进行解密，由于d是e关于t的模逆元，公钥和私钥的关系也就相当于函数与反函数，解密流程为：decrypt=encrypt**d mod N</span><br>decrypt = (encrypt ** d) % N<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The decrypted data is: &quot;</span>)<br><span class="hljs-built_in">print</span>(decrypt)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Web</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
